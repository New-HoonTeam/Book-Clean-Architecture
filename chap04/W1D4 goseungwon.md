# 4. 유스케이스 구현하기

아키텍처에서 각 계층이 느슨한 결합을 하고 있으면 도메인 코드 모델링의 자유도가 높다. 
DDD부터 풍부하거나, 빈약한방법 등 여러 방법으로 도메인 모델을 만들 수 있다.

헥사고날 아키텍처는 도메인 중심이기 때문에 도메인 모델 구현을 먼저 해보겠다.

### 도메인 모델 구현하기

도메인 모델을 구현한다.

### 유스케이스 둘러보기

예시로 든 유스케이스를 둘러보면 다음과 같은 단계가 있다.

1. 입력을 받는다.
2. 비즈니스 규칙을 검증한다.
3. 모델 상태를 조작한다.
4. 출력을 반환한다.

유스케이스는 인커밍 어댑터로부터 입력을 받는데, 유스케이스 코드는 도메인에만 집중해야 하기 때문에 유효성 검증은 다른 곳에서 처리해야 한다.

하지만 유스케이스는 비즈니스 규칙을 검증할 책임이 있다. 그리고 도메인 엔티티와 이 책임을 공유한다.

이게 무슨 말인가? 
입력 유효성 검증과 비즈니스 규칙 검증은 다르다. 이는 추후에 다뤄진다.

비즈니스 규칙을 충족하면 유스케이스는 입력 → 모델 상태 변경 → 영속성 어댑터가 상태 전달 후 저장 하게 된다. 이때 유스케이스는 또 다른 아웃고잉 어댑터를 호출할 수도 있다.

![image](https://user-images.githubusercontent.com/85796588/210564830-85024470-f7a0-4d99-8fd0-f03e7f1aa071.png)

그림과 같이 서비스에서 usecase를 구현하고, 아웃고잉포트를 호출하고, 도메인의 상태를 변경한다.

### 입력 유효성 검증

어댑터에서 검증 → 유효성 검증을 각 어댑터에서 모두 구현해야 한다. 휴먼에러 야기

어플리케이션 검증 → 어플리케이션에서 검증해야 유효하지 않은 입력값을 받지 않는다.

그럼 어플리케이션 내부 어디서 유효성 검증을 해야할까?

→ 유스케이스는 안된다. 입력 모델(SendMoneyCommand) 에서 다루도록 해보자. (정확히는 입력모델의 생성자.)

생성자에서 유효한지 체크하고, 파이널을 지정해 재할당할 수 없게 만든다.

SendMoneyCommand는 유스케이스 API의 일부여서 인커밍 포트 패키지에 위치한다. 그러므로 유효성 검증이 애플리케이션의 코어에(육각형 내부)에 남아있지만, 유스케이스 코드를 오염시키지 않는다.

자바는 Bean Validation을 사용하자.

필드가 많아 빌더패턴을 사용하는 경우에 생성자를 private으로 만들고 빌더의 build()메서드 내부에 검증 로직을 넣는 경우도 있다. → 추후 필드가 변경됨에 따라 빌더 코드에 필드를 추가하는걸 잊게 된다. → 차라리 생성자를 사용하자.

### 유스케이스마다 다른 입력 모델

각기 다른 유스케이스에 동일한 입력 모델 검증을 사용하게 되면 관심사를 요염시키기 마련이다. → 각 유스케이스 전용 입력 모델을 만들자.

### 비즈니스 규칙 검증하기

입력 검증과 다르게 비즈니스 규칙 검증은 유스케이스 로직의 일부이다. 그리고 애플리케이션의 핵심이기에 잘 다뤄야한다. 

이를 구분하는 방법은? → 비즈니스 규칙 검증은 도메인 모델의 현재 상태에 접근한다.

입력 검증(구문 검증), 비즈니스 검증(의미적인 검증)이라 봐도 좋다.

예를들어 송금되는 금액은 0보다 커야한다. → 입력 검증

출금 계좌에서 잔고보다 많이 출금할 수 없다. → 비즈니스 검증

**이제 구분을 했으니 검증하는법을 알아보자.**

가장 좋은 방법은 도메인 엔티티 안에 비즈니스 규칙을 넣는 것이다. 다른 방법으로 유스케이스에서 사용해도 좋다.

때에 따라서 복잡한 비즈니스 규칙은 먼저 DB단에서 검증하는 경우도 있다.

### 풍부한 도메인 vs 빈약한 도메인

풍부한 도메인 - 코어에 있는 엔티티에 가능한 많은 도메인 로직(비즈니스 규칙, 상태변경등)이 구현된다. 이때 유스케이스는 도메인 모델의 진입점으로 사용된다. 

빈약한 도메인 - 엔티티는 필드와 getter, setter로 구성되어 있다. 그렇기 때문에 유스케이스에 도메인 로직을 가지고 있다. 풍부함은 유스케이스에게 있다.

이 책에서는 방법에 정답은 없다고 한다. 

지금까지 빈약한 도메인이 깔끔하고 클린한 코드로 생각하고 배워왔다. 책에서의 얘기가 흥미로워서 구글링을 좀 해봤는데, 빈약한 도메인은 행위 메서드가 없다.

행위 메서드가 없는게 어때서? → 객체 지향 설계의 사상과 상반된다. 지금까지 풍부한 도메인을 만들어보지 않았지만, 시도해볼 가치가 있다고 생각된다.

DDD를 해보진 않았지만, 이 책에서 말한 것 처럼 핵심 로직은 도메인 계층에 넣고, 서비스 계층을 얇게 만드는게 핵심이라 한다. 

서비스 계층에 도메인 로직이 있다면, 도메인 모델이 주는 이점을 버리는 것.

### 유스케이스마다 다른 출력 모델

**출력은 호출자에게 꼭 필요한 정보만 담돼, 구체적일수록 좋다.**

유스케이스들 간에 출력 모델을 공유하게 되면 강한 결합이 생기게 된다. 이는 어플리케이션이 커짐에 따라서 문제를 야기하기 때문에 SRP를 적용하고 모델을 분리하자.

같은 이유로 도메인 엔티티를 입/출력 모델로 사용하지 말자.

### 읽기 전용 유스케이스는 어떤가?

예를들어 계좌 잔액 조회 기능을 위해 유스케이스를 새로 구현해야 할까?

프로젝트 맥락에서 유스케이스로 분류되는 경우도 있지만, 어플리케이션 관점에서는 간단한 쿼리이기 때문에 **쿼리 서비스**를 만들어 구현하자.

읽기 전용 쿼리가 쓰기 가능한 유스케이스와 명확하게 구분되기 때문에 CQRS(Command- Query Responsibility Segregation) 개념과 아주 잘맞는다.

### 유지보수 가능한 소프트웨어를 만드는 데 어떻게 도움이 될까?(이해 안됨)

입출력 모델을 독립적으로 모델링 한다면 원치않는 부수효과를 피할 수 있다.

이게 무슨말이지?

→ 유스케이스별 모델이 있으면, 유스케이스를 명확하게 이해할 수 있고, 장기적으로 유지보수하기도 더 쉽다. 또한 여러 개발자가 여러 유스케이스를 동시에 작업할 수 있다.

하지만 각 유스케이스마다 별도의 모델을 만들어야 하고, 이 모델과 엔티티를 매핑해야 한다.
