# 4장 유스케이스 구현하기

## 도메인 모델

![Untitled](https://user-images.githubusercontent.com/39071638/212552203-6e306795-8d36-4e36-b19b-0aeadb973bb8.png)
![Untitled 1](https://user-images.githubusercontent.com/39071638/212552206-47e0d559-323a-4c3b-a993-fc4364717453.png)
## 유스 케이스 둘러보기

유스케이스가 하는 일의 순서

![Untitled 2](https://user-images.githubusercontent.com/39071638/212552213-ee3af384-4556-4803-b909-aec04fe5764e.png)
인커밍 어댑터로부터 입력을 받는다

→ 입력 유효성을 따지지 않는다. 유효성을 검증하는 것으로 유스케이스를 오염시키고 싶지 않기 때문. 유스케이스 코드는 비즈니스 로직에만 전념을 해야 한다 그렇기 때문에 비즈니스 규칙은 검증을 한다

## 입력 유효성 검증

- 생성자에서 검증

![Untitled 3](https://user-images.githubusercontent.com/39071638/212552218-ba00add1-4713-4501-85f2-8a92160e8976.png)
![Untitled 4](https://user-images.githubusercontent.com/39071638/212552221-b834931a-1b77-4a08-9736-3f96571c2865.png)
- Bean Validation

![Untitled 5](https://user-images.githubusercontent.com/39071638/212552226-1e521cb9-ef8a-49ca-895a-6aec8ee3ba4a.png)
- Self validation 구현

## 생성자의 힘

- 빌더의 경우

필드를 입력하는 것을 까먹을 위험이 존재한다….

하지만 생성자를 사용하면, 컴파일 에러가 발생해서 필드 입력을 까먹는 사태를 방지할 수 있다.

~~IDE를 믿자~~

## 유스케이스마다 다른 입력 모델

각 유스케이스별로 별도의 입력 모델을 만들면

다른 유스케이스와의 결합을 제거해서 불필요한 부수효과가 발생하지 않게 된다

## 비즈니스 규칙 검증

- 구문상의 검증

입력을 검증하는 것

- 의미적인 검증

비즈니스 규칙을 검증하는 것

둘의 정확한 차이? 검증을 할 때 엔티티가 필요한가?

정확히는 비즈니스 규칙을 검증할 때는 도메인의 현재 상태에 접근해야 하지만 입력 유효성을 검증할 때는 그럴 필요가 없다.

이를 바탕으로 해당 코드들의 위치를 어디에 둘지 생각을 하면, 코드들이 구현될 위치 선정에 도움이 된다.

## 풍부한 도메인 vs 빈약한 도메인

### 풍부한 도메인

엔티티 안에서 가능한 많은 도에인 로직이 구현된다

엔티티들은 상태를 변경하는 메서드를 제공, 비즈니스 규칙에 맞는 유효한 변경만을 허용

여기서 유스케이스는 도메인의 진입점으로 동작함

### 빈약한 도메인

엔티티 자체는 getter, setter만은 포함함. 굉장히 얇다. 어떠한 도메인 로직도 가지고 있지 않음

도메인 로직은 유스케이스에서 구현되어있음

풍부함이 엔티티가 아닌 유스케이스에서 구현되어있음

## 유스케이스마다 다른 출력 모델
