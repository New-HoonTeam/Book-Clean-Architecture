### 단일 책임 원칙

Single Responsibility Principal(SRP)의 일반적인 해석은 다음과 같다.
**“하나의 컴포넌트는 오로지 한 가지 일만 해야 하고, 그것을 올바르게 수행해야 한다.”**

필자는 이는 단어를 직관적으로 해석한 것일 뿐 진정한 단일 책임 원칙은 다음과 같다고 생각한다.
**“컴포넌트를 변경하는 이유는 오직 하나뿐이어야 한다.”**

변경할 이유가 단 하나인 컴포넌트는 한 가지 일만 하게 될 것이고 다른 부분이 변경되어도 해당 컴포넌트는 여전히 기대한 대로 동작할 수 있다.
**문제는 변경할 이유라는 것이 컴포넌트 간 의존성을 통해 너무 쉽게 전파된다는 점**이다.

![IMG1](https://p1dgey.notion.site/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F226abe2b-2643-4ab6-b1ef-82adfcfd46c4%2FUntitled.png?id=fc93c4ca-b163-4cff-82ef-15b0f1f8149b&table=block&spaceId=b76551b9-9f24-4a91-9bcd-340caa404f60&width=2000&userId=&cache=v2)

그림에서 컴포넌트 E의 경우에는 의존하는 것이 없기 때문에 새로운 요구사항이나 E의 자체 기능을 수정할 때 말고는 변경할 이유가 없다. 그러나 다른 모든 컴포넌트에 의존하는 A의 경우에는 어떤 컴포넌트가 변경되든지 그에 맞게 항상 변경할 여지가 있다.

---

### 부수효과에 관한 이야기

클라이언트 입장에서도 특정 프로젝트에서 컴포넌트 간 의존성이 복잡하고 이상하게 되어있을 때 수정에 대한 비용을 너무 많이 감당하게 되고 해당 프로젝트를 이어받거나 리팩터링하는 업무 강도도 높을 수 밖에 없어진다.

---

### 의존성 역전 원칙

계층형 아키텍처에서 계층 간 의존성은 항상 다음 계층인 아래 방향을 가리킨다. 따라서 단일 책임 원칙을 고수준에서 적용할 때 하위 계층에 비해 상위 계층이 변경할 이유가 더 많아지게 된다.

더 구체적으로 도메인 계층이 영속성 계층을 의존하고 있기 때문에 영속성 계층이 변경되면 도메인 계층 또한 변경할 수 밖에 없다. 도메인 코드는 핵심 코드이기 때문에 변경을 최소화하거나 의존성을 제거할 필요가 있다.

**기존에 도메인 → 영속성 의존관계에서 도메인 ← 영속성으로 의존성을 역전시키면 어떨까?**

![IMG2](https://p1dgey.notion.site/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F5d40488c-60e1-46b0-9bf0-dc1017791d7e%2FUntitled.png?id=c5959e2b-1b93-4e68-b30d-895b9b305080&table=block&spaceId=b76551b9-9f24-4a91-9bcd-340caa404f60&width=1980&userId=&cache=v2)

도메인 코드가 영속성 계층에 의존적이지 않도록 의존성을 역전시킴으로써 문제를 해결할 수 있다.

---

### 클린 아키텍처

> 클린 아키텍처에서는 설계가 비즈니스 규칙의 테스트를 용이하게 하고, 비즈니스 규칙은 프레임워크, 데이터베이스, UI 기술, 그 밖의 외부 애플리케이션이나 인터페이스로부터 독립적일 수 있다.
> 
> 
> 로버트 C. 마틴
> 

이는 도메인 코드가 바깥으로 향하는 어떤 의존성 없이 모든 의존성이 도메인 코드를 향해야함을 의미한다.

![IMG3](https://p1dgey.notion.site/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F13f2ebb1-f71a-4ae2-a6e8-781cc8df4983%2FUntitled.png?id=d86a2069-0e61-460b-8742-83d966c147f5&table=block&spaceId=b76551b9-9f24-4a91-9bcd-340caa404f60&width=1950&userId=&cache=v2)

도메인 코드에서는 어떤 영속성 프레임워크나 UI 프레임워크가 사용되는지 알 수 없기 때문에 특정 프레임워크에 특화된 코드를 가질 수 없고 비즈니스 규칙에 집중할 수 있다.

만약 영속성 계층에서 ORM 프레임워크를 사용한다고 가정한다면, **도메인 계층과 영속성 계층은 서로 모르기(혹은 몰라야 하기) 때문에** **각각의 엔티티 클래스를 정의하는 것이 바람직**하다.
즉, **도메인 계층과 영속성 계층이 데이터를 주고받을 때, 두 엔티티를 서로 변환**해야 한다는 것이다.
(물론 도메인 계층과 다른 계층들 사이에서도 마찬가지)

---

### 헥사고날 아키텍처

![IMG4](https://p1dgey.notion.site/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F74d82210-3c09-4843-b006-4f05f4490a11%2FUntitled.png?id=839142fd-e11c-46ec-89f7-815947cf99a8&table=block&spaceId=b76551b9-9f24-4a91-9bcd-340caa404f60&width=1990&userId=&cache=v2)

육각형 내부에서 외부로 향하는 의존성이 없기 때문에 마틴이 클린 아키텍처에서 제시한 의존성 규칙이 그대로 적용되고 외부에서 코어를 향해 의존성을 갖는다.

육각형 바깥에는 애플리케이션과 상호작용하는 다양한 어댑터들이 있다.
좌측은 애플리케이션 코어를 호출하기 때문에 애플리케이션을 주도하는 어댑터이고, 우측은 애플리케이션 코어에 의해 호출되기 때문에 애플리케이션에 의해 주도되는 어댑터들이다.

애플리케이션 코어와 외부 어댑터들 간의 통신을 가능하기 위해서는 코어가 각각의 포트를 제공해야 한다.
주도하는 어댑터에는 그러한 포트가 코어 내부 클래스들에 의해 구현되고 호출되는 인터페이스가 될 것이고, 주도되는 어댑터에게는 그러한 포트가 어댑터에 의해 구현되고 코어에 의해 호출되는 인터페이스가 될 것이다.

---

### 유지보수 가능한 소프트웨어를 만드는 데 어떻게 도움이 될까?

클린 아키텍처, 헥사고날 아키텍처 중 무엇이든 의존성을 역전시켜 도메인 코드가 다른 바깥쪽 코드에 의존하지 않게 함으로써 영속성과 UI에 특화된 모든 문제로부터 도메인 로직의 결합을 제거하고 코드를 변경할 이유의 수를 줄일 수 있다. 결과적으로 변경할 이유가 적어지기 때문에 유지보수성이 더 좋아진다.

또한 도메인 코드는 비즈니스 문제에 딱 맞도록 자유롭게 모델링될 수 있고, 영속성과 UI 코드도 각각의 문제에 맞게 자유롭게 모델링될 수 있다.
