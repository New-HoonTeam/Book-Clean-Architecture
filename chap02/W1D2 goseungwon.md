# 2. 의존성 역전하기

### 단일 책임 원칙 (이해 안됨)

많은 사람들이 단일 책임 원칙을 오해하고 있다.

> 하나의 컴포넌트는 오로지 한 가지 일만 해야하고, 그것을 올바르게 수행해야 한다.
> 

실제 srp의 정의는 다음과 같다.

> 컴포넌트를 변경하는 이유는 오직 하나뿐이어야 한다. (의존성?)
> 

이 섹션은 이해가 되지 않기 때문에 통째로 인용해보겠다.

```java
만약 컴포넌트를 변경할 이유가 한 가지라면 우리가 어떤 다른 이유로 소프트웨어를 변경하더라도 
이 컴포넌트에 대해서는 전혀 신경 쓸 필요가 없다. 
소프트웨어가 변경되더 라도 여전히 우리가 기대한 대로 동작할 것이기 때문이다.
```

### 부수효과

srp를 잘 지키지 않는 경우, 컴포넌트를 변경하면 주변 컴포넌트도 영향을 받게 된다.

### 의존성 역전 원칙

레이어 아키텍처에서 하위 레이어는 상위 레이어에 의존성에 따라 변경이 잦아진다.

다른 레이어에 의해 변경하기 싫을 때, 이 의존성을 제거하는 방법이 있을까? → DIP

양쪽 코드를 모두 제어할 수 있는 경우 interface를 통해 의존성으로부터 자유로워질 수 있다.

### 클린 아키텍처 (이해 안됨)

클린아키텍처 = 테스트 용이, 컴포넌트 독립적

클린아키텍처 만드는 법 → 도메인 코드가 바깥으로 의존성이 없어야 한다.

![image](https://user-images.githubusercontent.com/85796588/210323054-8ab432c4-b064-4316-aaf7-3e26e57fb9d9.png)

도메인 계층이 외부 계층과 철저히 분리되어야 하기 때문에 어플리케이션의 엔티티에 대한 모델을 각 계층에서 유지보수 해야한다. ORM에서 엔티티를 DTO로 변환해서 사용한 경험을 떠올려 보자

### 헥사고날 아키텍처

![image](https://user-images.githubusercontent.com/85796588/210323110-2741ee63-976b-47a5-8e49-26064145a665.png)

위와 동일한 느낌이다. 다만 육각형 안의 엔티티와 상호작용 하는 유스케이스가 있고 외부로 향하는 의존성이 없다.

육각형 바깥에는 다양한 어댑터들이 여러 시스템과 상호작용을 한다.

### 유지보수 가능한 소프트웨어를 만드는 데 어떤 도움이 될까?

위에서 말한 아키텍처는 모두 DIP를 통해 도메인 코드를 중심으로 다른 바깥 코드에 의존하지 않게 만든다.

그럼으로 도메인 로직의 변경할 이유를 줄일 수 있다. → 유지보수성이 좋아진다.
