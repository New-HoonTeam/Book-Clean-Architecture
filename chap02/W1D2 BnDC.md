1장에서 계층형 아키텍처에 대한 문제점을 지적했으니, 
이번 장에서는 대안에 대한 이야기를 하고자 한다. 
그 전에 단일 책임 원칙(Single Responsibility Principle, SRP)

의존성 원칙(Dependency Inversion Principle, DIP)에 대해 살펴보자.

# 단일 책임 원칙

- 컴포넌트를 변경하는 이유는 오직 하나뿐이어야 한다.
- 책임 = 변경할 이유 → 책임은 곧 의존성이다.
- 만약 어떤 컴포넌트를 변경할 이유가 한 가지라면, 
다른 이유로 소프트웨어가 변경되었다면 이 컴포넌트에 대해서는 신경 쓸 필요가 없다.

변경할 이유라는 것은 컴포넌트 간의 의존성을 통해 너무도 쉽게 전파된다.

![image](https://user-images.githubusercontent.com/86050295/210579152-bdb701a2-0528-4137-84aa-d79984121e14.png)

A의 경우 모든 컴포넌트에 의존하고 있기 때문에 
다른 어떤 컴포넌트가 바뀌든지 같이 바뀌어야 한다

→ 단일 책임 원칙을 위반하기 때문에 
시간이 갈수록 변경하기가 더 어려워지고 그로 인해 변경 비용도 증가한다.

→ 어떤 컴포넌트이 다른 컴포넌트에 의해 변경될 가능성 커지면, 
컴포넌트를 바꾸는 것이 다른 컴포넌트가 정상 동작하지 않는 원인으로 작용할 수 있다.

(의존성 설정을 제대로 못했을 때 =단일 책임 원칙을 지키지 않았을 때, 일어나는 부수 효과)

# 부수효과에 관한 이야기

단일 책임 원칙을 지키지 않은 코드를 유지 보수하거나 기능 추가를 할 때, 

- 코드가 실제로 어떤 일을 하는지를 이해햐기 쉽지 않고,
- 코드의 한 영역을 변경했더니 다른 영역에서 부수효과가 생겨나기 일쑤였다.

클라이언트에 전반적인 변경이 더 적고, 
구현 비용이 더 저렴한 (핵심적인 특정 컴포넌트를 변경해야 하는 ) 방식 제안 

→ 클라이언트의 거절하고, 더 이상하고 비용이 많이 드는 방법 고수 

⇒ 과거의 개발팀이 코어 컴포넌트를 변경했을 때 발생했던 부수효과가 다시 발생할 것을 우려

# 의존성 역전 원칙

계층형 아키텍처에서 계층 간 의존성은 항상 다음 계층인 아래 방향을 가리킨다.

→ 영속성 계층을 변경할 때마다 잠재적으로 도메인 계층도 변경해야 한다.

→ 그런데 영속성 코드가 바뀐다고 해서 애플리케이션에서 
가장 중요한 코드인 도메인 코드까지 바꾸고 싶지 않다.

⇒ 의존성 역전 원칙으로 도메인 코드와 영속성 코드 간의 의존성을 역전

영속성 계층의 레포지토리가 도메인 계층의 엔티티에 의존하기 때문에 순환 의존성 발생

→ DIP 적용

![image](https://user-images.githubusercontent.com/86050295/210579341-09306b50-ae7a-4bd8-8763-dc8c8e64a4c4.png)

도메인 로직을 영속성 코드로 부터 해방

# 클린 아키텍처

클린 아키텍처 

좋은 설계 : 도메인 코드가 바깥으로 향하는 어떤 의존성도 없는 설계 
(모든 의존성이 도메인 코드를 향하도록 하는 설계)

→ 비즈니스 규칙에 대한 테스트 용이하게 함

→ (프레임 워크, 데이터베이스, UI 기술, 외부 인터페이스로 부터) 비즈니스 규칙이 독립적일 수 있도록 함

![image](https://user-images.githubusercontent.com/86050295/210579589-1f200f6e-d927-4526-be98-982ff7548eff.png)

아키텍처의 코어

- 도메인 엔티티
- 유스케이스(앞에서 서비스라고 불렸던 것)이 단일 책임을 갖기 위해 좀 더 세분화되어 있다
    
    → 넓은 서비스 문제를 피할 수 있음? 어떻게
    (추측) 예초에 서비스 자체에서 많은 것을 의존(책임) 지게 하지 않도록 함으로 
    넓은 서비스 문제를 애초에 만들지 않는 것
    

코어 주변

- 비즈니스 규칙을 지원하는 애플리케이션의 다른 컴포넌트들 존재
- 지원 = 영속성 제공, UI 제공 등을 의미
- 다른 서드파티 컴포넌트에 어댑터를 제공

application core = 도메인 계층 + 애플리케이션 계층 

도메인 코드 비즈니스 규칙에 집중, 도메인 코드를 자유롭게 모델링

도메인 주도 설계 순수한 형태로 적용

클린아키텍처의 대가(trade off)

- 계층별로 엔티티 모델을 따로 두어 각각 유지보수 해야 한다.
- 계층별로 데이터를 주고 받을 때, 각 계층의 엔티티를 서로 변환해야 한다.
    
    ex) ORM을 사용할 시 영속화 계층의 엔티티와 서비스 계층의 엔티티를 따로 관리
    

→ 도메인 코드와 프레임워크의 결합이 제거된 바람직한(?) 상태

엔티티에 기본 생성자를 추가하도록 강제 
도메인 모델에는 포함해서는 안 될 프레임워크에 특화된 결합의 예

차후 여러 매핑 전략에 대해 살펴볼 예정

ex) 도메인 계층과 영속성 계층의 결합을 그대로 수용하는 매핑 하기 전략

# 육각형 아키텍처(헥사고날 아키텍처)

![image](https://user-images.githubusercontent.com/86050295/210579809-1432dd47-85f0-46f2-ac3a-bbf8501442cd.png)

애플리케이션 코어가 육각형으로 표현 - 팔각형이어도 된다. 모양은 상관 없음

애플리케이션이 다른 시스템이나 어댑터와 연결되는 
4개 이상의 면을 가질 수 있음을 보여주기 위해 사각형 대신 육각형을 사용

육각형 내부 

도메인 엔티티 + (도메인 엔티티와 상호작용 하는) 유스케이스

→ 유각형 외부로 향하는 의존성이 없기 때문에 
마틴이 클린 아키텍처에서 제시한 의존성 규칙이 그대로 적용

모든 의존성이 코어를 향한다.

육각형 바깥

(애플리케이션과 상호작용하는) 다양한 어댑터

- 웹 브라우저와 상호작용하는 웹 어댑터
- 외부 시스템과 상호작용하는 어댑터
- 데이터베이스와 상호작용하는 어댑터

애플리케이션 코어와 어댑터들 간의 통신이 가능 → 애플리케이션 코어가 각각의 포트를 제공

- 주도하는 어댑터 (driving adapter) : 포트가 코어에 있는 유스케이스 클래스들에 의해 구현, 호출되는 인터페이스
- 주도되는 어댑터(driven adapter) : 어댑터에 의해 구현되고 코어에 의해 호출되는 인터페이스

포트와 어댑터 아키텍처로도 알려져 있음

가장 바깥쪽 계층 애플리케이션과 다른 시스템 간의 번역을 담당하는 어댑터로 구성

포트와 유스케이스 구현체를 결합해서 애플리케이션 계층을 구성할 수도 있음

→ 두 가지가 애플리케이션 인터페이스를 정의하기 때문

마지막 계층에는 도메인 엔티티가 위치

# 유지보수 가능한 소프트웨어를 만드는 데 어떻게 도움이 될까?

도메인 코드가 다른 바깥쪽 코드에 의존하지 않게 함

→ 영속성과 UI에 특화된 모든 문제로부터 도메인 로직의 결합을 제거

→ 코드를 변경할 이유의 수를 줄일 수 있다.

→ 변경할 이유가 적을수록 유지보수성은 더 좋아진다.

도메인 코드는 비즈니스 문제에 딱 맞도록 자유롭게 모델링 가능

영속성 코드, UI 코드도 영속성 문제와 UI 문제에 맞게 자유롭게 모델링 가능

다음장에서 애플리케이션 패키지 구조를 만들고 
의존성 주입의 역할에 대해 논의하는 것부터 시작 할 것이다.
