# 1장 계층형 아키텍쳐의 문제점은 무엇일까?

### 기존의 계층형 아키텍쳐

![Untitled](https://user-images.githubusercontent.com/39071638/212551815-0b15e133-abdf-4a5f-baa4-123cd7f237d1.png)

기존의 아키첵쳐

- 맨 위의 `웹 계층`에서 요청을 받아서 `도메인/비즈니스 계층`의 서비스로 요청을 보냄
- 서비스에서는 비즈니스 로직을 수행하고, 엔티티를 변경하거나 추가하기 위해서 `영속성 계층`에 접근을 함

계층 기반의 아키텍쳐 구조는 견고한 구조로서 계층을 잘 이해하고 로직을 구성하면 도메인 로직을 웹과 영속성과는 독립적으로 구성할 수 있다

잘 만들어진 계층형 아키텍처는 선택의 폭을 넓히고, 변화하는 요구사항과 외부 요인에 빠르게 적응할 수 있게 해준다. 그리고 엉클 밥(Uncle Bob)2에 의하면 이것이 바로 아키 텍처의 전부다

이런데 문제점은 과연 무엇일까?

# 계층형 아키텍쳐는 DB주도 설계를 유도한다

정의에 따르면 전통적인 계층형 아키텍쳐의 토대는 `DB`이다.

상위 계층은 하위 계층에 의존을 하기 때문에 자연스럽게 영속성 계층 즉 DB에 의존할 수 밖에 없다.

개발자는 App의 핵심적인 비즈니스 로직을 구성하는 것이 주 업무이다. 

App의 상태(state)보다는 행동(behavior)을 중심으로 모델링을 해야 한다.

즉 우리가 집중해야할 계층은 영속성 계층이 아닌 도메인 계층이다

하지만 계층형 아키텍쳐를 선택하게 된다면 자연스럽게 DB주도 설계를 하기 때문에 영속성 계층을 중심으로 아키텍쳐를 구성하게 된다.

이러한 DB주도 설계를 이끌어 내는 가장 큰 이유는 ORM프레임워크의 사용 때문이다. 

![Untitled 1](https://user-images.githubusercontent.com/39071638/212551829-3745d7ad-7e1e-4ca9-a696-ff9293a88d33.png)

위 그림과 같이 ORM에 의해 관리되는 엔티티들은 일반적으로 영속성 계층 아래 위치하게 되는데 이렇게 되면 영속성 계층과 도메인 계층 사이에서 강한 결합이 생기게 되고, 서비스는 영속성 계층을 비즈니스 로직 처럼 사용하게 된다. 그리고 즉시/지연 로딩, DB 트랜잭션, 캐시 flush와 같이 영속성 계층과 관련된 작업들을 해 주어야 한다.

# 지름길을 택하기 쉬워진다

전통적 아키텍쳐의 유일한 규칙은 본인의 하위 계층에만 의존할 수 있다는 점이다.

물론 다른 규칙이 존재할 수 있겠으나 강제하지는 않는다

상위 계층의 컴포넌트에 접근해야한다면, 간단하게 컴포넌트를 내리면 된다.

하지만 이런 식으로 계층을 변경한다면??? 나중에는 쉽게 계층을 변경하려고 할 것이다.

자고로 원래 처음이 어려운 법이니깐

![Untitled 2](https://user-images.githubusercontent.com/39071638/212551836-905c1f03-79f1-4c26-97d1-3f9f5ddfe021.png)
영속성 계층을 그렇게 둔다면 위와 같은 구조로 변경되기 쉽상이다. 영속성 계층은 계속 뚱뚱해지고,

본래 다른 계층에 있어야 할 헬퍼와 유틸리티가 영속성 계층으로 들어오게 된다.

# 테스트하기 어려워진다

![Untitled 3](https://user-images.githubusercontent.com/39071638/212551842-d69ec10f-e879-4817-9c11-340d1c69a8b4.png)
간단한 엔티티 테스트를 진행한다고 가정하자. 그러면 위 그림과 같이 계층을 건너 뛰고서, 다른 계층으로 접근하는 시도를 하게 된다. 하지만 이런다면 크게 두 가지 문제점이 발생한다

- 간단한 로직이더라도 웹 계층에 비즈니스 로직이 생긴다
- 웹 테스트를 진행할 때, 도메인 계층 뿐만이날 영속성 계층도 mocking해야 한다

# 유스케이스를 숨긴다

개발자가 기능을 추가한다고 하면 보통 새로운 코드를 추가 하는 것을 선호한다.

하지만 대부분의 경우에는 유지 보수를 해야 한다.

하지만 계층형 아키텍쳐의 경우 코드에서 정확히 찾고자하는 유스케이스를 찾기가 힘들 수 있다.

![Untitled 4](https://user-images.githubusercontent.com/39071638/212551847-c0b728b6-6dc6-4adb-a541-17d2375eb21c.png)
특히 위의 그림과 같이 서비스의 너비가 매우 넓은 코드에서는 더더욱 그렇다.

넓은 서비스는 영속성 계층에 더 많은 의존성을 가지게 되고, 서비스를 의존하는 웹 계층도 많아지게 된다.

이렇게 되면 서비스를 수정하는데 오래 걸리고, 작업해야할 유스케이스를 찾는 것 부터 유지보수하기가 매우 어려워진다.

# 동시 작업이 어려워진다.

개발 작업은 개발자가 많다고 해서 무작정 속도가 나오지는 않는다.

5배 많은 개발진을 투입한다고 해도, 5배 빠른 속도로 결과물의 나오지 않는다는 말이다. 

특히 중간에 인원이 추가된다고 한다면 인원들이 코드를 파악하는데 걸리는 시간도 존재하기 때문에 오히려 시간이 지체된다고 볼 수 있다.

그리고 계층형 아키텍쳐의 특성상, 여러 레이어에서 동시 작업이 어렵다.

내가 도메인 계층을 담당한다고 해서 무작정 개발을 시작할 수 없다는 말이다. 도메인 계층의 하위 계층인 영속성 계층의 작업의 선행이 이루어 저야 해당 계층의 작업이 가능하다.

웹 게층도 마찬가지이다. 

또한 코드의 넓은 서비스의 경우에는 서로 다른 서비스를 동시에 작업하는 것은 매우 어렵다.  merge 했을 경우 충돌이 일어날 수도 있으며, 코드를 롤백해야할 수도 있기 때문이다.
