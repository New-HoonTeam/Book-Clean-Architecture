코드를 보는 것만으로도 어떤 아키텍처인지 파악할 수 있다면 좋지 않을까?

- 코드를 구성하는 몇 가지 방법
- 육각형 아키텍처를 반영하는 패키지 구조 소개
- 송금하기 유스케이스를 통해 코드를 구조화하기 위한 여러 가지 방법들 소개


# 계층으로 구성하기

![image](https://user-images.githubusercontent.com/86050295/210837694-83dac9b2-fece-457f-bcec-41d8cf8af555.png)



1. 공통적인 기능이나 특성으로 묶이지 않았다

web 패키지에 UserController, 
domain 패키지에 UserService, UserRepository, User를 추가하고 
persistence 패키지에 UserRepositoryImpl을 추가하게 될 것 

→ 추가적인 구조가 없다면, 서로 연관되지 않은 기능(User vs Account)들이 
섞여서 예상치 못한 부수효과를 일으키는 구조

1. 애플리케이션이 어떤 유스케이스들을 제공하는지 파악할 수 없다.

AccountService, AccountController가 어떤 기능과 서비스를 제공하는지는 
서비스 내에 메서드들을 들여다 봐야한다. 

⇒ 패키지 구조를 통해서 아키텍처를 파악할 수 없다.

어떤 기능이 웹 어댑터에서 호출되는지, 
영속성 어댑터가 도메인 계층에 어떤 기능을 제공하는지 한 눈에 알아볼 수 없다.

인커밍 포트와 아웃고잉 포트가 코드 속에 숨겨져 있다.

- 인커밍 포트 : 값을 전달받는 포트
- 아웃고잉 포트 : 외부로 값을 내보내는 포트

# 기능으로 구성하기

‘계층으로 구성하기’ 방법의 몇 가지 문제를 해결해보자.
![image](https://user-images.githubusercontent.com/86050295/210837782-e3e87e8b-e016-4d92-bf43-a4584c4bd179.png)

- 계좌와 관련된 모든 코드를 최상위의 account 패키지에 넣었다
- 계층 패키지들도 없앴다.
- 외부에서 접근되면 안 되는 클래스들에 대해 package-private 접근 수준을 이용해 패키지 안의 경계를 강화 할 수 있다. → 각 기능 사이의 불필요한 의존성을 방지
- AccountService의 책임을 좁히기 위해 SendMonyService로 클래스명을 바꿨다.
’송금하기’ 유스케이스를 구현한 코드는 클래스명만으로도 찾을 수 있게 됐다.
→ ’소리치는 아키텍처’라고 명명 : naming만으로 기능을 우리에게 잘 알려주기 때문

그러나 기능에 의한 패키지 방식은 
계층에 의한 패키징 방식보다 아키텍처의 가시성을 훨씬 더 떨어뜨린다.

- 어댑터를 나타내는 패키지명이 없다
- 인커밍 포트, 아웃고잉 포트를 확인할 수 없다.
- 도메인 코드와 영속성 코드 간의 의존성 역전으로 SendMoneyService가 
AccountRepository 인터페이스만 알고 있고 구현체는 알 수 없도록 했음에도,
package-private 접근 수준을 이용해 도메인 코드가 실수로 영속성 코드에 의존하는 것을 막을 수 없다

아키텍처 다이어그램에서 어떤 박스를 가리켰을 때 
코드의 어떤 부분(어떤 패키지가)이 해당 박스(어떤 기능)를 책임지는 지 
바로 알 수 있는 보다 표현력 있는 패키지 구조를 만들어 보자

# 아키텍처적으로 표현력 있는 패키지 구조

육각형 아키텍처의 핵심 요소인 
엔티티, 유스케이스, 인커밍/아웃고잉 포트, 인커밍/아웃고잉 어댑터를
표현하는 패키지 구조를 구성해 보자.

![image](https://user-images.githubusercontent.com/86050295/210837960-0e693948-292e-498d-b2ef-6597085898ed.png)



최상위에는 account 패키지가 있고,
각 요소들은 패키지 하나씩에 직접 매핑 된다.

## 구조 소개

그 다음 레벨에 adaptor, domain, application 패키지가 있다.

- domain 패키지 : 도메인 모델이 속한 패키지
- application 패키지 : 도메인 모델을 둘러싼 서비스 계층을 포함한다.
    - SendMoneyService는 인커밍 포트 인터페이스인 SendMoneyUseCase를 구현하고,
    아웃고잉 포트 인터페이스이자 영속성 어댑터에 의해 구현된 
    LoadAccountPort와 UpdateAccountStatePort를 사용한다.
- adaptor 패키지는 인커밍 어댑터와 아웃고잉 어댑터를 포함한다.
    - BuckPal의 경우 web 어댑터와 persistence 어댑터로 이뤄진 웹 애플리케이션이다.

## 접근제어자

패키지 많다는 것은 모든 것을 public으로 만들어서 
패키지 간의 접근을 허용해야 한다는 것을 의미하는 게 아닐까?

- 적어도 어댑터 패키지에 대해서는 그렇지 않다.
    
    application 패키지 내에 있는 포트 인터페이스를 통하지 않고는 
    바깥에서 호출되지 않기 때문에 pacakge-private 접근 수준으로 둬도 된다. 
    그러므로 애플리케이션 계층에서 어댑터 클래스로 향하는 의존성은 있을 수 없다.
    
- application 패키지와 domain 패키지 내의 일부 클래스들은 public으로 지정해야 한다.
    
    어댑터에서 접근 가능해야 하는 포트들은 public 이어야 한다.
    domain 클래스들은 서비스, 어댑터에서도 접근 가능하도록 public이어야 한다.
    
- 서비스는 인커밍 포트 인터페이스 뒤에 숨겨질 수 있기 때문에 public일 필요가 없다.

어댑터 코드를 자체 패키지로 이동시키면 
필요할 경우 하나의 어댑터를 다른 구현으로 쉽게 교체할 수 있다는 장점이 있다.

간단하게 관련 아웃고잉 포트들만 새로운 어댑터 패키지에 구현하고 기존 패키지를 지우면 된다.

## 장점

이 패키지 구조는 아키텍처-코드 갭(architecture-code gap) 혹은 
모델-코드 갭(model-code gap)을 효과적으로 다룰 수 있는 강력한 요소다.

→ 아키텍처가 코드에 직접적으로 매핑될 수 없으니 패키지 구조에 아키텍처를 표현하여 해결

⇒ 패키지 구조가 아키텍처를 반영할 수 없다면, 
시간이 지남에 따라 코드는 점점 목표하던 아키텍처로부터 멀어지게 될 것이다.

또 다른 매력적인 장점 DDD 개념에 직접적으로 대응시킬 수 있다

- 다른 바운디드 컨텍스트와 소통할 수 있는 account는 바운디드 컨텍스트에 해당한다.
- domain 패키지 내에서는 DDD가 제공하는 모든 도구를 이용해 우리가 원하는 어떤 도메인 모델이든 만들 수 있다.

표현력 있는 패키지 구조가 아키텍처 간의 갭을 줄일 수 있게 해주지만 
어쩔 수 없이 아키텍처-코드 갭을 넓히고 아키텍처를 반영하지 않는 
패키지 구조를 만들어야 하는 경우도 생길 수 있다.

# 의존성 주입의 역할

클린 아키텍처의 가장 본질적인 요건은 2장에서 배웠듯이 
애플리케이션 계층이 인커밍/아웃고잉 어댑터에 의존성을 갖지 않는 것이다.

![image](https://user-images.githubusercontent.com/86050295/210838156-4a27c09f-7008-4e17-ae13-e24363411dbb.png)

예제 코드의 웹 어댑터와 같이 인커밍 어댑터에 대해서는 그렇게 하기가 쉽다. 
제어 흐름의 방향이 어댑터와 도메인 코드 간의 의존성 방향과 같은 방향이기 때문

아웃고잉 어댑터에 대해서 제어 흐름의 반대 방향으로 
의존성을 돌리기 위해 의존성 역전 원칙을 이용해야 한다.

- 애플리케이션 계층에 인터페이스를 만들고 
어댑터에 해당 인터페이스를 구현한 클래스를 두면 된다.
- 이 인터페이스가 포트다. 애플리케이션 계층은 
어댑터의 기능을 실행하기 위해 이 포트 인터페이스를 호출한다

그런데, 포트 인터페이스를 구현한 실제 객체를 누가 애플리케이션 계층에 제공해야 할까?

이 때, 의존성 주입을 활용할 수 있다. 
모든 계층에 의존성을 가진 중립적인 컴포넌트를 하나 도입하는 것이다. 
이 컴포넌트는 아키텍처를 구성하는 대부분의 클래스를 초기화하는 역할을 한다.

앞의 그림 3.4에서 중립적인 의존성 주입 컴포넌트는 
`Accountcontroller`, `SendMoneyService`, `AccountPersistenceAdapter` 
클래스의 인스턴스를 만들 것이다. 
`AccountController`가 `SendMoneyUseCase`인터페이스를 필요로 하기 때문에 
의존성 주입을 통해 `SendMoneyService` 클래스의 인스턴스를 주입한다. 

컨트롤러는 인터페이스만 알면 되기 때문에 
자신이 `SendMoneyService` 인스턴스를 실제로 가지고 있는지도 모른다.

`SendMoneyService`인스턴스를 만들 때도 
의존성 주입 메커니즘이 `LoadAccountPort` 인터페이스를 구현한
`AccountPersistenceAdapter` 클래스의 인스턴스를 주입할 것이다.

9장에서 스프링 프레임워크를 이용해 
애플리케이션을 초기화하는 방법에 대해 좀 더 살펴보겠다.

# 유지보수 가능한 소프트웨어를 만드는 데 어떻게 도움이 될까?

이번 장에서는 육각형 아키텍처의 패키지 구조를 살펴봤다. 
코드에서 아키텍처의 특정 요소를 찾으려면 
이제 아키텍처 다이어그램의 박스 이름을 따라 패키지 구조를 탐색하면 된다. 
이로써 의사소통, 개발, 유지보수 모두가 조금 더 수월해진다.

다음 장에서는 애플리케이션 계층, 웹 어댑터, 영속성 어댑터를 이용해서 
유스케이스를 하나 구현하면서 패키지 구조와 의존성 주입에 대해 조금 더 자세히 살펴본다.
