# 3장 코드 구성하기

# 계층으로 구성하기

![Untitled](https://user-images.githubusercontent.com/39071638/212552098-c7af92a3-8cdd-4d1e-b29c-dbadace1bd6a.png)
위와 같이 웹, 도메인, 영속성 등으로 걔층으로 구성할 경우는 어떨까??

보통 이렇게 구현하는 것이 대부분이다.

하지만 위와 같은 구조는 다음과 같은 이유로 최적의 구조가 아니다

1. App의 기능 조각(functional slice)나 특성(feature)을 구분 짓는 패키지 경계가 없다
    - 사용자를 관리하는 기능을 추가한다고 하면, web, persistence, domain 모든 패키지에 각각 파일을 추가하게 될 것이다.
    - 추가적인 구조가 없다면, 빠르게 서로 연관되지 않은 기능들끼리 예상하지 못한 부수효과가 발생할 가능성이 농후해진다.
2. App이 어떤 유스케이스들을 제공하는지 파악하기 어렵다
    - Service와 Controller가 각각 무슨 기능을 제공하는지 파악하기가 어렵다
    - 특정 기능을 찾기 위해서는 각 파일에 들어가서 특정 메서드를 찾아야 한다
3. 그리고 패키지 구조를 통해서 우리가 목표로 하는 아키텍쳐를 파악하기가 어렵다.
    - 헥사고날이라고 가정하면 어댑터를 찾기 위해서 web, persistence 계층을 봐야 한다.

# 기능으로 구성하기

![Untitled 1](https://user-images.githubusercontent.com/39071638/212552105-c501acf6-0ed0-47f3-82e2-7a1f63f35b72.png)
위와 같이 Account 즉 계좌와 관련된 기능에 관련된 코드를 account 패키지에 몰아 넣었다.

이는 클래스의 이름만으로도 해당 기능을 찾을 수 있게 되었다. 그렇기 때문에 이는 소리치는 아케틱쳐(screaming architecture) 라 명명된 바 있다.

하지만, 이는 **아키텍쳐의 가시성을 떨어뜨린다**…

어댑터, 인커밍/아웃고잉 포트 등을 확인할 수가 없다.

그리고 도메인 코드와 영속성 코드 간의 의존성으 역전시켜서 Service와 Repo의 인터페이스만 알고 있고 구현체는 알 수 없도록 했음에도, package-private 접근 수준을 이용해 도메인 코드가 실수로 영속성 코드에 접근하는 것을 막을 수 없다.

# 아키텍쳐적으로 표현력 있는 구조

![Untitled 2](https://user-images.githubusercontent.com/39071638/212552109-7b8636cc-cf31-44bf-b76b-2ba32a787258.png)
위의 그림은 헥사고날 아키텍쳐의 구조적으로 핵심적이 요소를 모두 가지고, 표현하는 아키텍쳐이다.

위와 같은 구조는 패키지가 많이 때문에 public으로 모든 패키지 간에 접근을 허용해야 할까?

적어도 어댑터 패키지에 대해서는 그렇지 않다. 이 패키지 내부의 모든 클래스들은 application 패키지 내에 있는 포트 인터페이스를 통하지 않고는 바깥에서는 호출되지 않기 때문에 package-private 수준으로 둬도 된다.

하지만 application 패키지와 domain 패키지 내부의 일부 클래스들은 public으로 지정해야한다. 의도적으로 접근 가능해야 하는 포트들은 public 이어야한다.

도메인 클래스들은 서비스, 잠재적으로 어댑터에서도 접근 가능하도록 public이어야함

서비스는 인커밍 포트 뒤로 숨으면 되므로 public일 필요가 없음

어댑터 코드를 자체 패키지로 이동시키면 필요할 경우 하나의 어댑터를 다른 구현으로 쉽게 교체할 수 있다는 장점도 있다ㅏ. → key-value DB에서 SQL 기반의 DB로 교체한다고 하면, 간단하게 아웃고잉 포트들만 수정하고 기존 패키지를 지우면 

# 의존성 주입의 역할

![Untitled 3](https://user-images.githubusercontent.com/39071638/212552115-f8f1f598-015e-4fe8-8a54-737735b9b2a5.png)
