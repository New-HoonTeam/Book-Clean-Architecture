# 3. 코드 구성하기

### 패키지 구조

1. 추가적인 구조를 구성하자.
    
    패키지 구조를 만들 때 레이어만 구분한다면 나중에 엉망진창 묶음으로 변모한다.
    
2. 한눈에 보기 쉽게 구성하자.
    
    @@Controller @@Service라는 클래스 명은 어떤 유스케이스를 구현했는지 판단 할 수 없다. 클래스 내의 어떤 메서드가 그에 대한 책임을 수행을 찾아야 한다.
    
    이와 같이 패키지 구조를 통해 아키텍처를 파악할 수 없다.
    

그럼 어떻게 구성하라는 말인가?

### 기능으로 구성하기

기능에 의한 패키지 구조는 계층에 의한 패키징 보다 가시성을 떨어트린다.

어댑터, 인커밍 포트, 아웃고잉 포트를 확인 할 수 없다. 의존성 역전을 해도 같은 패키지에 있기 때문에 package-private이어도 실수로 의존할 수 있다.

그래서 어떻게 구성하라는 말인가?

### 아키텍처를 표현하는 패키지 구조

헥사고날 아키텍처를 예를 들겠다.

![image](https://user-images.githubusercontent.com/85796588/210323271-1462a724-ee04-401e-9a28-ab7c085c25ce.png)

![image](https://user-images.githubusercontent.com/85796588/210323296-e26c0570-f47d-436f-9cfe-52f91130ccd3.png)

account관련 유스케이스를 분류 하는 패키지가 있고, 어댑터, 도메인, 어플리케이션 요소들을 패키지 하나씩 매핑한다. SendMoneyService는 SendMoneyUseCase를 구현하고, 아웃고잉 포트는 영속성 어댑터가 구현한다. 이처럼 패키지 구조를 통해 아키텍처 구조가 어떤지 유추할 수 있도록 만들었다.

한 눈에 봐도 패키지가 많은데, 그렇다면 패키지간 접근을 위해 package-public을 해야하는가?

→ 어댑터 패키지는 포트 패키지를 구현하기 때문에 package-private으로 만들어 우발적인 의존성을 차단한다.

하지만 application과 domain의 일부 클래스는 의도적으로 adapter에서 접근이 가능해야 하기 떄문에 public으로 만들어야 한다.

하지만 이 또한 규칙을 잘 지켜야 하며 상황에 따라서 규칙을 어겨야 하는 경우도 있다.

개발에 정답은 없다. 항상 본인의 상황에 맞게 방법을 맞춰가자

### 의존성 주입 역할

패키지 구조도 중요하지만, 본질적인 것은 애플리케이션 계층이 어댑터에 의존성을 갖지 않는 것이다.

어플리케이션 계층에 인터페이스를 → 어댑터 계층에서 구현한다.

![image](https://user-images.githubusercontent.com/85796588/210323333-7f8127a0-0335-4728-96c4-f4420dc66153.png)

그렇게 되면 컨트롤러는 UseCase만 알면 되고, Service는 의존성 주입을 하면 된다.

### 유지보수 가능한 SW만들기

이번장은 헥사고날 아키텍처의 구조를 살펴보았다.

예시가 헥사고날 아키텍처였지만 현재 가장 친숙하고, 많이 사용하는 레이어드 아키텍처에도 적용하기 충분한 내용들 이었다. 각자의 레이어에 침범하지 않고, DI를 통해 의존성이 한 방향으로 흐르게 만든다. 특히 도메인 계층을 중심으로 엄격히 관리해야된다 생각한다.

패키지 구조 또한 어떤 아키텍처를 사용하는지, 어떤 역할을 하는지 패키지만 보고도 유추할 수 있도록 녹여내야 된다고 한다.
